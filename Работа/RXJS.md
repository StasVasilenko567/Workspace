Библиотека, встроенная в Ангуляр, по сути, является "модом на ассинхронность". Предоставляет потоки, в качестве паттерна **Наблюдатель** (Observer)

## Потоки

Потоки (observables) - Замена промисов. Реализовано через паттерн Наблюдатель. Имеет такой функционал:
1. Подписка через subscribe. При создании подписки, мы передаем колбек, который будет исполняться, когда в поток передадут данные. Пример:
```ts
this.options?.changes.subscribe(
	(c) => { c.toArray().forEach((item: ElementRef) => {
		if (index === this.getIndexById(this.firstSelected)) {
			item.nativeElement.classList.add('checkmark__selected');
		} else {
			item.nativeElement.classList.add('checkmark');
		}
	index++;
	})
});
```

...

# Операторы

## Обычные операторы

Как правило, возвращают поток. Бывают разных типов:
- Создания ([`of`](https://rxjs.dev/api/index/function/of), [`from`](https://rxjs.dev/api/index/function/from), [`fromEvent`](https://rxjs.dev/api/index/function/fromEvent), [`interval`](https://rxjs.dev/api/index/function/interval));
- Преобразования ([`map`](https://rxjs.dev/api/operators/map), [`scan`](https://rxjs.dev/api/operators/scan), [`buffer`](https://rxjs.dev/api/operators/buffer));
- Фильтрации ([`filter`](https://rxjs.dev/api/operators/filter), [`take`](https://rxjs.dev/api/operators/take), [`skip`](https://rxjs.dev/api/operators/skip), [`distinct`](https://rxjs.dev/api/operators/distinct));
- Обработки ошибок ([`catchError`](https://rxjs.dev/api/operators/catchError), [`retry`](https://rxjs.dev/api/operators/retry), [`onErrorResumeNext`](https://rxjs.dev/api/index/function/onErrorResumeNext));
- Условия ([`skipUntil`](https://rxjs.dev/api/operators/skipUntil), [`skipWhile`](https://rxjs.dev/api/operators/skipWhile), [`takeUntil`](https://rxjs.dev/api/operators/takeUntil), [`takeWhile`](https://rxjs.dev/api/operators/takeWhile));
- Математические ([`min`](https://rxjs.dev/api/operators/min), [`max`](https://rxjs.dev/api/operators/max), [`count`](https://rxjs.dev/api/operators/count));
- Утилиты ([`tap`](https://rxjs.dev/api/operators/tap), [`delay`](https://rxjs.dev/api/operators/delay));
- Для Connectable Observable ([`share`](https://rxjs.dev/api/operators/share), [`shareReplay`](https://rxjs.dev/api/operators/shareReplay), [`publish`](https://rxjs.dev/api/operators/publish)).

Большинство операторов используются в pipe у потоков.

## Операторы высшего порядка

это операторы, которые работают с **Observable**, который является результатом других **Observable**. Они позволяют эффективно работать с потоками, которые внутри себя содержат другие потоки, и обрабатывать их асинхронно. Это часто используется для работы с асинхронными операциями, которые могут возвращать другие потоки, например, HTTP-запросы, таймеры или другие асинхронные события.

1. **`switchMap()`** — это оператор, который принимает функцию, возвращающую новый Observable. Этот новый Observable заменяет предыдущий, а старые потоки отменяются, если приходит новое значение. Это полезно для сценариев, где вам нужно только последнее значение из асинхронной операции (например, для автозаполнения в поле ввода).
2. **`mergeMap()`** (также известен как **`flatMap()`**) также принимает функцию, которая возвращает новый Observable, но в отличие от `switchMap`, он не отменяет предыдущие потоки. Все потоки, возвращенные функцией, будут работать параллельно. Это полезно, если вы хотите обрабатывать несколько потоков одновременно.
3. **`concatMap()`** — это оператор, который также принимает функцию, возвращающую новый Observable, но в отличие от `mergeMap`, он **не выполняет несколько потоков параллельно**. Он будет выполнять потоки **последовательно**, один за другим, ожидая завершения текущего потока перед тем, как начать следующий. Это полезно, когда важно, чтобы потоки обрабатывались в определенном порядке.
4. **`exhaustMap()`** — это оператор, который также принимает функцию, возвращающую новый Observable, но в отличие от других операторов, он игнорирует все новые значения, приходящие в поток, пока текущая асинхронная операция не завершится. Это полезно, когда нужно игнорировать новые запросы или действия, пока не завершится обработка текущего.
5. **`concatAll()`** — это оператор, который используется для объединения потоков, возвращаемых другими потоками. Он берет все вложенные Observables, эмитирует их значения последовательно, а не параллельно, что похоже на работу `concatMap()`, но используется без явной функции преобразования.
6. **`mergeAll()`** — это оператор, который используется для слияния всех вложенных Observables в один поток. В отличие от `concatAll()`, `mergeAll()` будет эмитировать значения из всех внутренних потоков одновременно.
7. **`switchAll()`** — это оператор, который похож на `switchMap()`, но он применяется к уже существующему потоку, который возвращает Observable. Он будет подписываться на новый поток и отменять подписку на предыдущие потоки, как только приходит новый элемент.
### Заключение

Операторы высшего порядка в **RxJS** позволяют эффективно работать с вложенными потоками и асинхронными операциями, такими как HTTP-запросы, таймеры, или любые другие асинхронные события. Они предоставляют гибкость в управлении выполнением, отмене или последовательности асинхронных операций.

- **`switchMap`** — используется для переключения потока и отмены предыдущих операций.
- **`mergeMap`** — позволяет выполнять потоки параллельно, не отменяя их.
- **`concatMap`** — выполняет потоки последовательно.
- **`exhaustMap`** — игнорирует новые потоки, пока текущая операция не завершится.
- **`concatAll`, `mergeAll`, `switchAll`** — применяются для работы с потоками, которые эмитируют другие потоки.